<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Text Cleaner + GPT Assistant v2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #010512;
            --card-bg: rgba(9, 14, 33, 0.85);
            --border: rgba(255, 255, 255, 0.08);
            --text: #f8fafc;
            --muted: #97a2c6;
            --primary: #6a7bff;
            --primary-strong: #8b5cf6;
            --success: #4ade80;
            --warning: #facc15;
            --error: #fb7185;
        }

        body.light {
            --bg: #f3f5fa;
            --card-bg: rgba(255, 255, 255, 0.9);
            --border: rgba(2, 6, 23, 0.08);
            --text: #0f172a;
            --muted: #5b6179;
            --primary: #4c5bff;
            --primary-strong: #7f6bff;
            --success: #16a34a;
            --warning: #b45309;
            --error: #dc2626;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: radial-gradient(circle at 10% 20%, rgba(100, 116, 255, 0.25), transparent 45%),
                radial-gradient(circle at 90% 10%, rgba(139, 92, 246, 0.25), transparent 55%),
                var(--bg);
            color: var(--text);
            padding: 32px 16px 48px;
        }

        .app-shell {
            max-width: 1220px;
            margin: 0 auto;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 32px;
            padding: 40px;
            box-shadow: 0 35px 80px rgba(0, 0, 0, 0.55);
            backdrop-filter: blur(24px);
            display: flex;
            flex-direction: column;
            gap: 32px;
        }

        header h1 {
            margin: 0;
            font-size: clamp(2rem, 4vw, 2.8rem);
            font-weight: 600;
        }

        header p {
            margin-top: 8px;
            color: var(--muted);
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .brand em {
            font-style: normal;
            font-size: 0.95rem;
            color: var(--muted);
        }

        .top-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .theme-toggle {
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text);
            cursor: pointer;
            font-weight: 600;
        }

        .theme-toggle:active {
            transform: scale(0.97);
        }

        body.light .theme-toggle {
            border-color: rgba(15, 23, 42, 0.15);
        }

        .app-body {
            display: flex;
            gap: 24px;
            align-items: flex-start;
        }

        .main-panel {
            flex: 1;
            min-width: 0;
        }

        .sidebar {
            width: 240px;
        }

        .side-nav {
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: sticky;
            top: 20px;
        }

        .nav-link {
            border-radius: 16px;
            padding: 12px 18px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            text-decoration: none;
            color: var(--text);
            font-weight: 600;
            background: rgba(255, 255, 255, 0.04);
            transition: transform 0.15s ease, border 0.15s ease;
        }

        .nav-link:hover {
            border-color: var(--primary);
            transform: translateX(4px);
        }

        .nav-link.active {
            background: linear-gradient(135deg, var(--primary), var(--primary-strong));
            border-color: transparent;
        }

        .sidebar small {
            display: block;
            margin-top: 16px;
            color: var(--muted);
            line-height: 1.4;
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 18px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .stat-card span {
            font-size: 0.9rem;
            color: var(--muted);
        }

        .stat-card strong {
            font-size: 1.45rem;
        }

        .auto-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .layout-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 28px;
        }

        textarea,
        input,
        button,
        select {
            font-family: inherit;
        }

        textarea,
        input[type="text"] {
            background: rgba(15, 21, 41, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-radius: 18px;
            padding: 12px 16px;
            font-size: 1rem;
            width: 100%;
            transition: border 0.2s ease, transform 0.2s ease;
        }

        textarea:focus,
        input:focus {
            outline: none;
            border-color: var(--primary);
            transform: translateY(-1px);
        }

        textarea {
            min-height: 150px;
            resize: vertical;
        }
        .card {
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.02);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card h3 {
            margin: 0;
            font-size: 1.15rem;
        }

        .card small {
            color: var(--muted);
        }

        .pattern-manager {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .pattern-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .pattern-actions button {
            flex: 0 0 auto;
        }

        .pattern-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .pattern-chip {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.03);
        }

        .pattern-chip.active {
            border-color: var(--primary);
            background: rgba(100, 116, 255, 0.11);
        }

        .chip-text {
            flex: 1;
            margin-right: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .chip-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .icon-button {
            width: 32px;
            height: 32px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: transparent;
            color: var(--text);
            font-size: 1rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .icon-button:hover {
            border-color: var(--primary);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.25);
            transition: 0.3s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .switch input:checked + .slider {
            background: linear-gradient(135deg, var(--primary), var(--primary-strong));
        }

        .switch input:checked + .slider:before {
            transform: translateX(20px);
        }

        .button-row,
        .btn-cluster {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        button {
            border: none;
            border-radius: 999px;
            padding: 12px 22px;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
            background: rgba(255, 255, 255, 0.08);
            transition: transform 0.18s ease, box-shadow 0.18s ease;
        }

        button.primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-strong));
            color: white;
            box-shadow: 0 12px 24px rgba(100, 116, 255, 0.35);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        button:not(:disabled):active {
            transform: scale(0.97);
        }

        .highlight-preview {
            border-radius: 20px;
            border: 1px dashed rgba(255, 255, 255, 0.2);
            padding: 16px;
            min-height: 120px;
            background: rgba(15, 21, 30, 0.7);
            overflow-y: auto;
            line-height: 1.6;
        }
        .highlight-preview mark {
            background: rgba(255, 0, 122, 0.2);
            border-bottom: 1px solid rgba(255, 0, 122, 0.6);
            color: var(--text);
        }

        .gpt-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .gpt-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .gpt-badge {
            width: 50px;
            height: 50px;
            border-radius: 16px;
            background: linear-gradient(135deg, var(--primary), var(--primary-strong));
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            letter-spacing: 0.04em;
        }

        .chat-window {
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(9, 12, 28, 0.75);
            padding: 20px;
            min-height: 180px;
            max-height: 320px;
            overflow-y: auto;
        }

        .assistant-message {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(100, 116, 255, 0.35);
            border-radius: 20px;
            padding: 18px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 260px;
            overflow-y: auto;
        }

        .history-card {
            border-radius: 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 14px 18px;
            background: rgba(255, 255, 255, 0.04);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .history-card small {
            color: var(--muted);
        }

        .history-card p {
            margin: 0;
            font-size: 0.95rem;
        }

        .history-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .pattern-summary {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .pattern-summary span {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 0.85rem;
        }

        .action-link,
        .link-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border-radius: 14px;
            padding: 10px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text);
            text-decoration: none;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.05);
        }

        .action-link:hover,
        .link-button:hover {
            border-color: var(--primary);
        }

        .status {
            font-size: 0.95rem;
            color: var(--muted);
            min-height: 22px;
        }

        .status.success { color: var(--success); }
        .status.warning { color: var(--warning); }
        .status.error { color: var(--error); }
        .status.info { color: var(--muted); }

        .quick-tips {
            border: 1px dashed rgba(255, 255, 255, 0.2);
            border-radius: 18px;
            padding: 14px 18px;
            background: rgba(255, 255, 255, 0.03);
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.95rem;
            color: var(--muted);
        }

        .quick-tips span {
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            font-weight: 500;
        }

        .hidden {
            display: none !important;
        }

        .muted {
            color: var(--muted);
        }

        @media (max-width: 720px) {
            .app-shell {
                padding: 24px;
            }
            .app-body {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
            }
            .pattern-actions {
                flex-direction: column;
            }
            button {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <main class="app-shell">
        <header>
            <div class="top-bar">
                <div class="brand">
                    <h1>Text Cleaner + GPT Assistant</h1>
                    <em>v2</em>
                </div>
                <div class="top-actions">
                    <button id="themeToggle" class="theme-toggle">Light Mode</button>
                    <a class="action-link" href="features.html">Insights</a>
                    <a class="action-link" href="instructions.html">GPT Guide</a>
                </div>
            </div>
            <p>Manage multiple removal patterns, inspect highlights, and push the cleaned text to GPT.</p>
            <div class="quick-tips">
                <span>Tip: Press Ctrl/Cmd + Enter to clean instantly.</span>
                <span>Auto-clean runs after you pause typing.</span>
                <span>Use Insights to restore older runs.</span>
            </div>
        </header>

        <section class="stats-panel">
            <div class="stat-card">
                <span>Original Length</span>
                <strong id="statOriginal">0</strong>
            </div>
            <div class="stat-card">
                <span>Cleaned Length</span>
                <strong id="statCleaned">0</strong>
            </div>
            <div class="stat-card">
                <span>Removed Segments</span>
                <strong id="statRemoved">0</strong>
            </div>
            <div class="stat-card">
                <span>Reduction %</span>
                <strong id="statPercent">0%</strong>
            </div>
        </section>

        <div class="app-body">
            <section class="main-panel">
                <section class="layout-grid">
                    <div class="left-column">
                        <section class="card">
                            <h3>Primary Pattern</h3>
                            <small>This text is always removed first and stored persistently.</small>
                            <textarea id="patternInput" placeholder="Enter base pattern..."></textarea>
                            <div class="btn-cluster">
                                <button id="clearPatternBtn" class="secondary">Clear Pattern</button>
                            </div>
                        </section>

                        <section class="card pattern-manager">
                            <div>
                                <h3>Additional Patterns</h3>
                                <small>Add, toggle, or remove patterns without losing them.</small>
                            </div>
                            <div class="pattern-actions">
                                <input type="text" id="patternAddInput" placeholder="Add another pattern" />
                                <button id="addPatternBtn" class="secondary">Add</button>
                                <button id="clearPatternsBtn" class="secondary">Clear All</button>
                            </div>
                            <div class="pattern-list" id="patternList"></div>
                        </section>

                        <section class="card">
                            <h3>Original Text</h3>
                            <textarea id="originalInput" placeholder="Paste your large block of text here..."></textarea>
                            <div class="btn-cluster">
                                <button id="cleanBtn" class="primary">Run Clean Now</button>
                                <button id="clearOriginalBtn" class="secondary">Clear Original</button>
                            </div>
                        </section>

                        <section class="card">
                            <h3>Removed Segments Preview</h3>
                            <small>Highlighted spans show exactly what will disappear.</small>
                            <div id="highlightPreview" class="highlight-preview">Start typing to preview removed segments.</div>
                        </section>
                    </div>

                    <div class="right-column">
                        <section class="card hidden" id="resultWrapper" aria-hidden="true">
                            <div class="button-row">
                                <h3 style="flex:1">Cleaned Result</h3>
                                <button id="toggleResultBtn" class="secondary">Show Result</button>
                            </div>
                            <textarea id="resultOutput" placeholder="Your cleaned text will drop here" readonly></textarea>
                            <div class="btn-cluster">
                                <button id="copyBtn" class="secondary">Copy Result</button>
                                <button id="downloadResultBtn" class="secondary">Download Result</button>
                            </div>
                        </section>

                        <section class="card gpt-section">
                            <div class="gpt-header">
                                <div class="gpt-badge">GPT</div>
                                <div>
                                    <h3>GPT Response</h3>
                                    <small>Organized like ChatGPT.</small>
                                </div>
                            </div>
                            <div class="chat-window" aria-live="polite">
                                <div id="gptResponse" class="assistant-message">The AI response will appear here.</div>
                            </div>
                            <div class="btn-cluster">
                                <button id="sendBtn" class="secondary">Send to GPT</button>
                                <button id="downloadGPTBtn" class="secondary">Download GPT Reply</button>
                            </div>
                        </section>
                    </div>
                </section>
            </section>

            <aside class="sidebar">
                <nav class="side-nav">
                    <a href="index.html" class="nav-link active">Cleaner</a>
                    <a href="features.html" class="nav-link">Insights & History</a>
                    <a href="instructions.html" class="nav-link">GPT Instructions</a>
                </nav>
                <small>Use the menu to access auto actions, history, and other secondary tools when you need them.</small>
            </aside>
        </div>

        <footer class="status info" id="status">Auto-clean keeps the result fresh. Enable auto actions above to streamline your workflow.</footer>
    </main>
    <script>
        const STORAGE_KEYS = {
            pattern: 'shadow_delete_text_pattern',
            extras: 'shadow_delete_extra_patterns',
            history: 'shadow_delete_clean_history',
            autoCopy: 'shadow_delete_auto_copy',
            autoSend: 'shadow_delete_auto_send',
            prompt: 'shadow_delete_promptnotes',
            summary: 'shadow_delete_pattern_summary',
            restore: 'shadow_delete_restore_request',
            theme: 'shadow_delete_theme',
            stats: 'shadow_delete_usage_stats'
        };

        const patternInput = document.getElementById('patternInput');
        const patternAddInput = document.getElementById('patternAddInput');
        const addPatternBtn = document.getElementById('addPatternBtn');
        const clearPatternsBtn = document.getElementById('clearPatternsBtn');
        const clearPatternBtn = document.getElementById('clearPatternBtn');
        const patternListEl = document.getElementById('patternList');

        const originalInput = document.getElementById('originalInput');
        const resultOutput = document.getElementById('resultOutput');
        const resultWrapper = document.getElementById('resultWrapper');
        const toggleResultBtn = document.getElementById('toggleResultBtn');

        const cleanBtn = document.getElementById('cleanBtn');
        const clearOriginalBtn = document.getElementById('clearOriginalBtn');
        const copyBtn = document.getElementById('copyBtn');
        const sendBtn = document.getElementById('sendBtn');
        const downloadResultBtn = document.getElementById('downloadResultBtn');
        const downloadGPTBtn = document.getElementById('downloadGPTBtn');
        const themeToggleBtn = document.getElementById('themeToggle');

        const gptResponseEl = document.getElementById('gptResponse');
        const highlightPreview = document.getElementById('highlightPreview');

        const statOriginal = document.getElementById('statOriginal');
        const statCleaned = document.getElementById('statCleaned');
        const statRemoved = document.getElementById('statRemoved');
        const statPercent = document.getElementById('statPercent');

        const statusEl = document.getElementById('status');

        const getUsageStats = () => {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEYS.stats) || '{"totalRuns":0,"totalRemoved":0}');
            } catch {
                return { totalRuns: 0, totalRemoved: 0 };
            }
        };

        const saveUsageStats = (stats) => {
            localStorage.setItem(STORAGE_KEYS.stats, JSON.stringify(stats));
        };

        const applyTheme = (theme) => {
            document.body.classList.toggle('light', theme === 'light');
            if (themeToggleBtn) {
                themeToggleBtn.textContent = theme === 'light' ? 'Dark Mode' : 'Light Mode';
            }
        };

        const currentTheme = localStorage.getItem(STORAGE_KEYS.theme) || 'dark';
        applyTheme(currentTheme);

        const isAutoCopyEnabled = () => localStorage.getItem(STORAGE_KEYS.autoCopy) === 'true';
        const isAutoSendEnabled = () => localStorage.getItem(STORAGE_KEYS.autoSend) === 'true';

        let extraPatterns = [];
        let historyEntries = [];
        let isResultVisible = false;
        let resultAvailable = false;
        let autoCleanTimer = null;
        const AUTO_CLEAN_DELAY = 350;
        let lastAutoSentText = '';

        const savedPattern = localStorage.getItem(STORAGE_KEYS.pattern);
        if (savedPattern) patternInput.value = savedPattern;

        try {
            extraPatterns = JSON.parse(localStorage.getItem(STORAGE_KEYS.extras) || '[]');
        } catch {
            extraPatterns = [];
        }

        try {
            historyEntries = JSON.parse(localStorage.getItem(STORAGE_KEYS.history) || '[]');
        } catch {
            historyEntries = [];
        }

        const getInstructions = () => localStorage.getItem(STORAGE_KEYS.prompt) || '';

        const pendingRestoreRaw = localStorage.getItem(STORAGE_KEYS.restore);
        if (pendingRestoreRaw) {
            try {
                const pending = JSON.parse(pendingRestoreRaw);
                if (pending && typeof pending === 'object') {
                    if (pending.original) {
                        originalInput.value = pending.original;
                    }
                    setStatus('Restored text from Insights. Clean whenever you are ready.', 'info');
                    scheduleAutoClean();
                }
            } catch {
                // ignore
            }
            localStorage.removeItem(STORAGE_KEYS.restore);
        }

        renderPatternList();
        setResultVisibility(false);
        updateResultAvailability(false);
        function setStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function setResultVisibility(show) {
            isResultVisible = show;
            resultWrapper.classList.toggle('hidden', !show);
            resultWrapper.setAttribute('aria-hidden', (!show).toString());
            toggleResultBtn.textContent = show ? 'Hide Result' : 'Show Result';
        }

        function updateResultAvailability(available) {
            resultAvailable = available;
            toggleResultBtn.disabled = !available;
            copyBtn.disabled = !available;
            sendBtn.disabled = !available;
            downloadResultBtn.disabled = !available;
            if (!available) setResultVisibility(false);
        }

        function escapeHtml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        const createId = () =>
            typeof crypto !== 'undefined' && crypto.randomUUID
                ? crypto.randomUUID()
                : `${Date.now()}-${Math.random().toString(16).slice(2)}`;

        function getActivePatterns() {
            const active = [];
            const base = patternInput.value;
            if (base.trim()) active.push(base);
            extraPatterns.filter((p) => p.active && p.text.trim()).forEach((p) => active.push(p.text));
            return active;
        }

        function renderPatternList() {
            if (!extraPatterns.length) {
                patternListEl.innerHTML = '<small class="muted">No additional patterns yet.</small>';
                return;
            }

            patternListEl.innerHTML = extraPatterns
                .map(
                    (pattern) => `
                    <div class="pattern-chip ${pattern.active ? 'active' : ''}" data-id="${pattern.id}">
                        <span class="chip-text" title="${escapeHtml(pattern.text)}">${escapeHtml(pattern.text)}</span>
                        <div class="chip-controls">
                            <label class="switch">
                                <input type="checkbox" ${pattern.active ? 'checked' : ''} data-action="toggle">
                                <span class="slider"></span>
                            </label>
                            <button class="icon-button" data-action="remove" title="Remove pattern">&times;</button>
                        </div>
                    </div>
                `
                )
                .join('');
        }

        patternListEl.addEventListener('click', (event) => {
            const chip = event.target.closest('.pattern-chip');
            if (!chip) return;
            const id = chip.getAttribute('data-id');
            const action = event.target.getAttribute('data-action');

            if (action === 'remove') {
                extraPatterns = extraPatterns.filter((p) => p.id !== id);
                persistPatterns();
                renderPatternList();
                setStatus('Pattern removed.', 'info');
                scheduleAutoClean();
            }
        });

        patternListEl.addEventListener('change', (event) => {
            const chip = event.target.closest('.pattern-chip');
            if (!chip) return;
            const id = chip.getAttribute('data-id');
            if (event.target.getAttribute('data-action') === 'toggle') {
                extraPatterns = extraPatterns.map((p) => (p.id === id ? { ...p, active: event.target.checked } : p));
                persistPatterns();
                renderPatternList();
                scheduleAutoClean();
            }
        });

        function persistPatterns() {
            localStorage.setItem(STORAGE_KEYS.extras, JSON.stringify(extraPatterns));
        }

        addPatternBtn.addEventListener('click', () => {
            const value = patternAddInput.value.trim();
            if (!value) {
                setStatus('Enter a pattern before adding.', 'warning');
                return;
            }

            extraPatterns.push({ id: createId(), text: value, active: true });
            patternAddInput.value = '';
            persistPatterns();
            renderPatternList();
            setStatus('Pattern added and activated.', 'success');
            scheduleAutoClean();
        });

        clearPatternsBtn.addEventListener('click', () => {
            extraPatterns = [];
            persistPatterns();
            renderPatternList();
            setStatus('All additional patterns cleared.', 'info');
            scheduleAutoClean();
        });

        clearPatternBtn.addEventListener('click', () => {
            patternInput.value = '';
            localStorage.removeItem(STORAGE_KEYS.pattern);
            setStatus('Primary pattern cleared.', 'info');
            scheduleAutoClean();
        });
        function scheduleAutoClean() {
            clearTimeout(autoCleanTimer);
            autoCleanTimer = setTimeout(() => runClean({ triggeredByAuto: true, showWarnings: false }), AUTO_CLEAN_DELAY);
        }

        function runClean({ triggeredByAuto = false, showWarnings = true } = {}) {
            const patterns = getActivePatterns();
            const original = originalInput.value;

            if (!patterns.length || !original) {
                updateResultAvailability(false);
                if (showWarnings) {
                    if (!patterns.length) setStatus('Add at least one active pattern to clean with.', 'warning');
                    else setStatus('Paste some text to clean.', 'warning');
                }
                renderHighlight(original, []);
                updateMetrics(original, original, []);
                persistPatternSummary([]);
                return false;
            }

            let working = original;
            const perPattern = [];
            patterns.forEach((pattern) => {
                const parts = working.split(pattern);
                const count = Math.max(parts.length - 1, 0);
                working = parts.join('');
                perPattern.push({ text: pattern, count });
            });

            resultOutput.value = working;
            updateResultAvailability(true);
            setResultVisibility(false);
            renderHighlight(original, patterns);
            updateMetrics(original, working, perPattern);
            persistPatternSummary(perPattern);
            const stats = getUsageStats();
            stats.totalRuns += 1;
            stats.totalRemoved += Math.max(original.length - working.length, 0);
            saveUsageStats(stats);
            addHistoryEntry({
                original,
                cleaned: working,
                timestamp: new Date().toISOString(),
                patterns: [...patterns]
            });

            if (triggeredByAuto) {
                setStatus('Text auto-cleaned as you type. Reveal the result or copy/send directly.', 'info');
            } else {
                setStatus('Clean complete. Reveal the result or move on to GPT.', 'success');
            }

            if (isAutoCopyEnabled()) {
                copyResult(true);
            }

            if (isAutoSendEnabled() && working && working !== lastAutoSentText) {
                lastAutoSentText = working;
                sendToGPT(true);
            }

            return true;
        }

        function renderHighlight(text, patterns) {
            if (!text) {
                highlightPreview.innerHTML = 'Start typing to preview removed segments.';
                return;
            }

            if (!patterns.length) {
                highlightPreview.innerHTML = 'Add active patterns to preview removals.';
                return;
            }

            let cursor = 0;
            let html = '';
            while (cursor < text.length) {
                let nextIndex = -1;
                let matchPattern = '';
                patterns.forEach((pattern) => {
                    if (!pattern) return;
                    const idx = text.indexOf(pattern, cursor);
                    if (idx !== -1 && (nextIndex === -1 || idx < nextIndex)) {
                        nextIndex = idx;
                        matchPattern = pattern;
                    }
                });

                if (nextIndex === -1) {
                    html += escapeHtml(text.slice(cursor));
                    break;
                }

                if (nextIndex > cursor) {
                    html += escapeHtml(text.slice(cursor, nextIndex));
                }

                html += `<mark>${escapeHtml(text.slice(nextIndex, nextIndex + matchPattern.length))}</mark>`;
                cursor = nextIndex + matchPattern.length;
            }

            highlightPreview.innerHTML = html;
        }

        function updateMetrics(original, cleaned, perPattern) {
            const originalLength = original.length;
            const cleanedLength = cleaned.length;
            const removedChars = Math.max(originalLength - cleanedLength, 0);
            const removalCount = perPattern.reduce((sum, p) => sum + p.count, 0);
            const percent = originalLength ? ((removedChars / originalLength) * 100).toFixed(1) : '0.0';

            statOriginal.textContent = originalLength;
            statCleaned.textContent = cleanedLength;
            statRemoved.textContent = removalCount;
            statPercent.textContent = `${percent}%`;
        }

        function persistPatternSummary(perPattern) {
            localStorage.setItem(STORAGE_KEYS.summary, JSON.stringify(perPattern));
        }

        function addHistoryEntry(entry) {
            if (!entry.original && !entry.cleaned) return;
            historyEntries.unshift(entry);
            historyEntries = historyEntries.slice(0, 6);
            localStorage.setItem(STORAGE_KEYS.history, JSON.stringify(historyEntries));
        }
        patternInput.addEventListener('input', () => {
            localStorage.setItem(STORAGE_KEYS.pattern, patternInput.value);
            scheduleAutoClean();
        });

        patternAddInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                addPatternBtn.click();
            }
        });

        originalInput.addEventListener('input', () => {
            scheduleAutoClean();
        });

        cleanBtn.addEventListener('click', () => runClean({ triggeredByAuto: false, showWarnings: true }));

        clearOriginalBtn.addEventListener('click', () => {
            originalInput.value = '';
            resultOutput.value = '';
            updateResultAvailability(false);
            renderHighlight('', []);
            updateMetrics('', '', []);
            persistPatternSummary([]);
            lastAutoSentText = '';
            setStatus('Original text cleared.', 'info');
        });

        toggleResultBtn.addEventListener('click', () => {
            if (!resultAvailable) {
                setStatus('Nothing to show yet. Clean some text first.', 'warning');
                return;
            }
            const nextVisibility = !isResultVisible;
            setResultVisibility(nextVisibility);
            setStatus(nextVisibility ? 'Showing cleaned text.' : 'Result hidden.', 'info');
        });

        themeToggleBtn?.addEventListener('click', () => {
            const nextTheme = document.body.classList.contains('light') ? 'dark' : 'light';
            localStorage.setItem(STORAGE_KEYS.theme, nextTheme);
            applyTheme(nextTheme);
        });

        async function copyResult(silent = false) {
            if (!resultAvailable) {
                if (!silent) setStatus('Clean the text first before copying.', 'warning');
                return;
            }
            const text = resultOutput.value;
            if (!text) {
                if (!silent) setStatus('Result is empty, nothing to copy.', 'warning');
                return;
            }

            try {
                await navigator.clipboard.writeText(text);
                if (!silent) setStatus('Cleaned text copied to clipboard.', 'success');
            } catch (error) {
                console.error('Clipboard error:', error);
                if (!silent) setStatus('Copy failed. Please try again.', 'error');
            }
        }

        copyBtn.addEventListener('click', () => copyResult(false));

        function downloadBlob(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        downloadResultBtn.addEventListener('click', () => {
            if (!resultAvailable) {
                setStatus('Clean the text before downloading.', 'warning');
                return;
            }
            downloadBlob(resultOutput.value, 'cleaned-text.txt');
            setStatus('Cleaned text downloaded.', 'success');
        });

        downloadGPTBtn.addEventListener('click', () => {
            const content = gptResponseEl.textContent.trim();
            if (!content || content === 'The AI response will appear here.') {
                setStatus('No GPT response to download yet.', 'warning');
                return;
            }
            downloadBlob(content, 'gpt-response.txt');
            setStatus('GPT response downloaded.', 'success');
        });

        async function sendToGPT(triggeredByAuto = false) {
            if (!resultAvailable) {
                if (!triggeredByAuto) setStatus('Clean the text first before sending to GPT.', 'warning');
                return;
            }

            const cleanedText = resultOutput.value;
            if (!cleanedText) {
                if (!triggeredByAuto) setStatus('Cleaned text is empty.', 'warning');
                return;
            }

            sendBtn.disabled = true;
            const originalLabel = sendBtn.textContent;
            sendBtn.textContent = 'Sending...';
            setStatus('Sending cleaned text to GPT...', 'info');

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: cleanedText, instructions: getInstructions().trim() })
                });

                const data = await response.json().catch(() => ({}));
                if (!response.ok) throw new Error(data.error || 'Failed to reach GPT.');

                gptResponseEl.textContent = data.reply?.trim() || 'GPT returned an empty response.';
                setStatus('GPT responded successfully.', 'success');
            } catch (error) {
                console.error('GPT request failed:', error);
                gptResponseEl.textContent = 'Unable to fetch response. Please try again later.';
                setStatus(error.message || 'Something went wrong.', 'error');
            } finally {
                sendBtn.disabled = false;
                sendBtn.textContent = originalLabel;
            }
        }

        sendBtn.addEventListener('click', () => sendToGPT(false));
    </script>
</body>
</html>

